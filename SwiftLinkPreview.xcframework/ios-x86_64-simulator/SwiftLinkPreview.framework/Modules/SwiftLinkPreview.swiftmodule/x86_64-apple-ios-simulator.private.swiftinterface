// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7.1 (swiftlang-5.7.1.135.3 clang-1400.0.29.51)
// swift-module-flags: -target x86_64-apple-ios12.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name SwiftLinkPreview
// swift-module-flags-ignorable: -enable-bare-slash-regex
import Foundation
import Swift
@_exported import SwiftLinkPreview
import UIKit
import _Concurrency
import _StringProcessing
public enum SwiftLinkResponseKey : Swift.String {
  case url
  case finalUrl
  case canonicalUrl
  case title
  case description
  case image
  case images
  case icon
  case video
  case price
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@objc @_inheritsConvenienceInitializers open class Cancellable : ObjectiveC.NSObject {
  public var isCancelled: Swift.Bool {
    get
  }
  open func cancel()
  @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers open class SwiftLinkPreview : ObjectiveC.NSObject {
  public var session: Foundation.URLSession
  final public let workQueue: Dispatch.DispatchQueue
  final public let responseQueue: Dispatch.DispatchQueue
  final public let cache: SwiftLinkPreview.Cache
  public static let defaultWorkQueue: Dispatch.DispatchQueue
  @nonobjc public init(session: Foundation.URLSession = URLSession.shared, workQueue: Dispatch.DispatchQueue = SwiftLinkPreview.defaultWorkQueue, responseQueue: Dispatch.DispatchQueue = DispatchQueue.main, cache: SwiftLinkPreview.Cache = DisabledCache.instance)
  @objc override dynamic public init()
  @objc public init(session: Foundation.URLSession?, workQueue: Dispatch.DispatchQueue?, responseQueue: Dispatch.DispatchQueue?, disableInMemoryCache: Swift.Bool, cacheInvalidationTimeout: Foundation.TimeInterval, cacheCleanupInterval: Foundation.TimeInterval)
  @discardableResult
  @nonobjc open func preview(_ text: Swift.String, onSuccess: @escaping (SwiftLinkPreview.Response) -> Swift.Void, onError: @escaping (SwiftLinkPreview.PreviewError) -> Swift.Void) -> SwiftLinkPreview.Cancellable
  @objc deinit
}
extension SwiftLinkPreview.SwiftLinkPreview {
  open func extractURL(text: Swift.String) -> Foundation.URL?
}
extension SwiftLinkPreview.SwiftLinkPreview : Foundation.URLSessionDataDelegate {
  @objc dynamic public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
}
public enum PreviewError : Swift.Error, Swift.CustomStringConvertible {
  case noURLHasBeenFound(Swift.String?)
  case invalidURL(Swift.String?)
  case cannotBeOpened(Swift.String?)
  case parseError(Swift.String?)
  public var description: Swift.String {
    get
  }
}
public protocol Cache {
  func slp_getCachedResponse(url: Swift.String) -> SwiftLinkPreview.Response?
  func slp_setCachedResponse(url: Swift.String, response: SwiftLinkPreview.Response?)
}
@_hasMissingDesignatedInitializers public class DisabledCache : SwiftLinkPreview.Cache {
  public static let instance: SwiftLinkPreview.DisabledCache
  public func slp_getCachedResponse(url: Swift.String) -> SwiftLinkPreview.Response?
  public func slp_setCachedResponse(url: Swift.String, response: SwiftLinkPreview.Response?)
  @objc deinit
}
open class InMemoryCache : SwiftLinkPreview.Cache {
  public init(invalidationTimeout: Foundation.TimeInterval = 300.0, cleanupInterval: Foundation.TimeInterval = 10.0)
  open func cleanup()
  open func slp_getCachedResponse(url: Swift.String) -> SwiftLinkPreview.Response?
  open func slp_setCachedResponse(url: Swift.String, response: SwiftLinkPreview.Response?)
  @objc deinit
}
extension Foundation.URLSession {
  public func synchronousDataTask(with url: Foundation.URL) -> (Foundation.Data?, Foundation.URLResponse?, Foundation.NSError?)
  public func synchronousDataTask(with request: Foundation.URLRequest) -> (Foundation.Data?, Foundation.URLResponse?, Foundation.NSError?)
}
public struct Response {
  public var url: Foundation.URL? {
    get
  }
  public var finalUrl: Foundation.URL? {
    get
  }
  public var canonicalUrl: Swift.String? {
    get
  }
  public var title: Swift.String? {
    get
  }
  public var description: Swift.String? {
    get
  }
  public var images: [Swift.String]? {
    get
  }
  public var image: Swift.String? {
    get
  }
  public var icon: Swift.String? {
    get
  }
  public var video: Swift.String? {
    get
  }
  public var price: Swift.String? {
    get
  }
  public init()
}
extension SwiftLinkPreview.SwiftLinkResponseKey : Swift.Equatable {}
extension SwiftLinkPreview.SwiftLinkResponseKey : Swift.Hashable {}
extension SwiftLinkPreview.SwiftLinkResponseKey : Swift.RawRepresentable {}
